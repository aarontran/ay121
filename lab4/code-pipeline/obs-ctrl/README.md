CIA Tracking/Observing software
================================================

Authors: Isaac Domagalski, Aaron Tran

The observing pipeline depends on the [ugradio code](https://github.com/AaronParsons/ugradio/tree/master/ugradio_code)
module, written by Aaron Parsons, Garrett Karto Keating, and Baylee Bordwell.

gen\_grid.py
----------------------------------------------------

This script generates a grid to observe over.

    Usage: gen_grid.py [options]
    Flags:
        -h: Print this help message and exit.
        -b: Lower bound on galactic latitude.
        -B: Upper bound on galactic latitude.
        -f: Force overwriting existing grid.
        -l: Lower bound on galactic longitude.
        -L: Upper bound on galactic longitude.
        -o: Output file to save the grid to.

observe.py
-----------------------------------------------------

This script communicates with the dish tracker and records raw spectra.

    usage: observe.py [-h] [-d] [-v] trpkl
    
    Take Leuschner spectra
    
    positional arguments:
      trpkl          Path of tracking.pkl
    
    optional arguments:
      -h, --help     show this help message and exit
      -d, --debug    debug mode, no data taken
      -v, --verbose  verbose mode

time\_home.py
----------------------------------------------------------

This script is for sending the dish to the home position and can optionally
create a default tracking status pickle. This script should be used sparingly.

tracking.py
---------------------------------------------------------------

This script controls the tracking of the dish and communicates with observe.py
so that proper data collection can take place.

    Usage: tracking.py [options]
    Flags:
        -h: Print this help message and exit.
        -H: Reset the telescope to the home position.
        -d: Enable debug mode (do not operate the dish).
        -g: Grid file to use for the tracking.
        -l: File containing the altitude limits.
        -L: Log file for the tracker.
        -s: Amount of points to step in the grid (default: 2).
        -t: Start time for observations (%Y-%m-%d-%H:%M).
        -T: Stop time for observations (%Y-%m-%d-%H:%M).
        -v: Enable verbose mode for the dish.

How tracking works...
----------------------------------------------------------

The main input to the tracking script is the grid file produced by
`gen_grid.py`. This grid specifies which coordinates to point to and whether or
not data already exists for those coordinates. This is useful since it creates a
well-defined plan for observing and it makes sure that no coordinates get
duplicated in data collection. The script `tracking.py` is uses the grid as a
set of tracking instructions for pointing the dish to certain coordinates. The
coordinates in the grid file are given as galactic coordinates and `tracking.py`
converts them into equatorial coordinates that it can use to send commands to
the dish. The grid file has a list of galactic longitudes for every galactic
latitude it traverses. The longitudes for every two latitudes are given in
reverse order to create a zigzag pattern for tracking. However, `tracking.py`
can be set to skip every other grid point and this can prevent the dish from
zigzagging. The main reason why something like that would be done would be if
observation time was limited.

In addition to tracking galactic coordinates, `tracking.py` must communicate
with `observe.py` so that it knows how long to track a point, when to turn the
noise diode on and off, and it must tell `observe.py` when it is OK to be
recording spectra. The communication between `tracking.py` and `observe.py` is
done by each script writing pickle files containing status that the other script
reads. For example, `tracking.py` saves a status dictionary containing the
observation status, the state of the noise diode, the coordinates being pointed
to, and the state of the noise diode. The script `observe.py` has a status
dictionary containing information on whether or not it is ready to make a
recording and the desired state of the diode. Setting these states on and off
allows synchronization between `tracking.py` and `observe.py`.

How observing works...
---------------------------------------------------------------------------

*Observing procedure*

observe.py takes as input the tracking .pkl generated by tracking.py, which
allows the two scripts to communicate.  The script creates an observing.pkl in
the same directory which signals (1) when we are ready to take data for the next
pointing, and (2) when we want the noise diode on/off.

When the tracking script has status 'tracking', indicating that it is
continuously pointing towards a single point on the sky (specified by galactic
longitude and latitude), and the observing script is 'ready', the observing
script collects the following data:

    with LO frequency = 1271.9 MHz, amplitude = 10
    collect 87 spectra without noise
    collect 9 spectra with noise

    with LO frequency = 1268.9 MHz, amplitude = 10
    collect 87 spectra without noise
    collect 9 spectra with noise

These (default) values are stored in the metadata pickle:
n\_obs = 87, n\_cal = 9, f\_low = 1268.9, f\_high = 1271.9, lo\_ampl = 10.
The metadata pickle additionally stores the pointing's galactic
latitude/longitude, grid indices (set by gen\_grid.py and tracking.py),
base filename, local time (PST/PDT), unix time (GMT), Julian date, and LST for
Leuschner (longitude = -122.15385).

The base filename for five output files contains galactic coordinates (degrees)
and grid indices.

    data_l_%06.2f_b_%06.2f_grid_%03d_%03d

Once the data are collected, the observing script sets its status to not 'ready'
and waits until the tracking script slews the telescope to its next point on the
sky.

*Integration times*

The (default) total integration time for both spectra is 87 * 2 * 0.692 sec/spec
= 120 seconds.  The (default) integration time for both noise spectra is 9 * 2 *
0.692 sec/spec = 12.5 seconds.  Some earlier spectra were collected with doubled
integration times.

From prior experience (i.e., lab manual, suggestions in class, early test data
etc), we choose 120 seconds to resolve features with T ~ 1 to 10 K.

The error of the noise calibration enters only through a sum term, so the error
is scaled by ~1/N where N is the number of channels summed.  We conservatively
take N ~ 4096 rather than 8192 (information lost from RFI removal, data cut at
passband edges, etc.).

We ask that the calibration sum error be no more than 1/10th of error arising
from uncertainty in each channel.  Since the calibration integration time will
be short, the calibration data is the main source of error in this sum.  Looking
at squared errors (as error scales with 1 / sqrt(time) ):

    0.01 * 1 / (integration time) ~ 1 / (calibration integration time) * 1 /
    4096

The integration time with noise should be at least 0.02x the integration
time of our actual data.

Here the calibration integration time is ~0.1x the integration time of our
actual data (enough to account for Caleb's N=2048 downsampling in RFI removal).
So we don't expect the calibration to contribute too much additional error.
